===========================================================
      PROJECT REPORT: ARRAYLEX LEXICAL ANALYZER
===========================================================
Developer: [Imong Pangalan]
Language: Java (Swing GUI)
Date: December 2025

-----------------------------------------------------------
1. OVERVIEW OF PROPOSED PL DESIGN
-----------------------------------------------------------
Name: ArrayLex

ArrayLex is a domain-specific language designed specifically 
for structured array declarations. It mimics the syntax of 
C-style languages but enforces strict tokenization rules 
to ensure data integrity.

Key Characteristics:
- Focus: Fixed-type array initialization.
- Paradigm: Imperative and Statically Typed.
- Design: Every statement must be explicitly terminated with 
  a semicolon (;), and data sets must be encapsulated within 
  curly braces {} to separate data from variable naming.



-----------------------------------------------------------
2. STRUCTURE OF THE CODE
-----------------------------------------------------------
The analyzer is built using a character-pointer scanning 
approach (Deterministic Finite Automaton logic) within Java.

- UI Layer: Uses 'javax.swing' to provide a window where users 
  can type code. It uses a JTable to show real-time results.
- Scanner Engine: The 'runAnalysis()' method uses a 'while' 
  loop and an index pointer to read the text character by 
  character.
- Logic Flow:
    - Whitespace: Automatically skipped to find the next lexeme.
    - Multi-digit Numbers: Uses a StringBuilder to group 
      consecutive digits (e.g., '50') into one NUMBER token.
    - Keywords vs Identifiers: Uses a Regex check to see if 
      a word is a reserved type (int, String) or a variable name.

-----------------------------------------------------------
3. SAMPLE INPUT: LEXEMES AND TOKENS
-----------------------------------------------------------

A. CORRECT LEXEMES (Samples)
Lexeme: "int"      -> Token: KEYWORD    (Type definition)
Lexeme: "numbers"  -> Token: IDENTIFIER (Variable name)
Lexeme: "{"        -> Token: L_BRACE    (Block start)
Lexeme: "50"       -> Token: NUMBER     (Literal value)

B. INCORRECT/INVALID TOKENS (Samples)
Lexeme: "@"        -> Token: UNKNOWN    (Unsupported symbol)
Lexeme: "#"        -> Token: UNKNOWN    (No preprocessor support)
Lexeme: "$"        -> Token: UNKNOWN    (Illegal character)

-----------------------------------------------------------
4. UNIQUE PL PRINCIPLE: "STRICT BLOCK ENCAPSULATION"
-----------------------------------------------------------
The defining principle of ArrayLex is Strict Block 
Encapsulation. This ensures the Lexer can always identify 
the start and end of a data structure without ambiguity.

Correct Input Sample:
   int[] scores = {90, 85, 70};

Why it's unique: 
In ArrayLex, the braces {} are not just style choices; 
they are required delimiters. By enforcing these tokens, 
the Lexer provides a clear roadmap for the Parser (the next 
stage) to ensure that array data is never "leaking" or 
unstructured.



-----------------------------------------------------------
INSTRUCTIONS TO RUN
-----------------------------------------------------------
1. Save the provided Java code as 'ArrayLexerGUI.java'.
2. Compile: javac ArrayLexerGUI.java
3. Run: java ArrayLexerGUI
4. Paste the 'Correct Input Sample' above into the text 
   box and click "Analyze".

===========================================================


EASIER EXPLANATIONS


===========================================================
      PROJECT REPORT: ARRAYLEX ANALYZER
===========================================================
Developer: [Imong Pangalan]
Language: Java

-----------------------------------------------------------
1. OVERVIEW OF THE LANGUAGE DESIGN
-----------------------------------------------------------
The developer created a simple language called "ArrayLex." 
This language is designed specifically for making lists 
of data, known as arrays. 

The goal of ArrayLex is to make sure that every list is 
labeled correctly and kept inside clear boundaries so the 
computer doesn't get confused.



-----------------------------------------------------------
2. HOW THE PROGRAM WORKS
-----------------------------------------------------------
The program works like a scanner. It looks at the text 
the user types and follows these steps:

- It reads the text one character at a time.
- It groups letters together to find "keywords" (like 'int').
- It groups digits together to find "numbers" (like '500').
- It identifies symbols like equals signs (=) and braces {}.
- If it sees a symbol it doesn't recognize (like @), it 
  marks it as "Unknown."

-----------------------------------------------------------
3. EXAMPLES OF INPUTS
-----------------------------------------------------------

A. CORRECT EXAMPLES:
- "int"      (The program identifies this as a KEYWORD)
- "myArray"  (The program identifies this as a NAME)
- "{"        (The program identifies this as a START SYMBOL)
- "25"       (The program identifies this as a NUMBER)

B. INCORRECT EXAMPLES:
- "@"        (The program labels this UNKNOWN)
- "#"        (The program labels this UNKNOWN)
- "$"        (The program labels this UNKNOWN)

-----------------------------------------------------------
4. THE UNIQUE PRINCIPLE: "STRICT BLOCKS"
-----------------------------------------------------------
The main rule of this language is called "Strict Blocks." 
This means that all data must be placed inside curly 
braces {}. 

Example: int[] numbers = {1, 2, 3};

This rule is unique because it forces the user to be very 
organized. By using these symbols, the program can easily 
see exactly where a list starts and where it ends. This 
stops errors before they happen.



-----------------------------------------------------------
HOW TO USE IT
-----------------------------------------------------------
1. The user opens the Java application.
2. The user types array code into the box.
3. The user clicks "Analyze."
4. The program shows a list of every piece it found and 
   what that piece represents.
===========================================================
